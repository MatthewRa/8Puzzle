(load 'PuzzleFuncs)
(defvar *OPEN* nil)
(defvar *CLOSED* nil)
(defvar *EXPANDED* 0)
(defvar *GENERATED* 0)
(defvar *DISTINCT* 0)

(defun DFID (lst)
    (let ((solution NIL))
        (setf *GENERATED* 0)
        (setf *DISTINCT* 0)
        (setf *EXPANDED* 0)
        (do ((x 1 (1+ x))) ((not (null solution)) solution);((> x 3) solution)
            (setf *OPEN* nil)
            (setf *CLOSED* nil)
            (setf solution (reverse (DFS lst x)))
        )
    )
)

(defun DFS (root bound)
    (let ((found nil) (current nil) (depth 0) (max (expt 4 (- bound 1))))
        (push (list root nil) *OPEN*)

        (do ((x 0 (1+ x))) ((or found (>= x max)) found)
            (setf current (car (last *OPEN*)))
            (setf *open* (remove (car (last *open*)) *open*))
            (if (IsSolved (car current)) (setf found current))

            (if (car (cdr current)) (setf depth (length current)) (setf depth 1))

            (push (car current) *CLOSED*)
            (if (< depth bound) (GenerateSuccessors current))
            (incf *EXPANDED*)
            (if (null *OPEN*) (setf x max))
        )
    )
)

(defun GenerateSuccessors (node)
    (let ((newNode nil))
        (setf newNode (MoveBlankLeft (car node)))
        (if newNode (incf *generated*))
        (when (and (not (null newNode)) (not (position newNode *CLOSED* :test #'equal))) (incf *DISTINCT*) (push (makeList node newNode) *OPEN*))
        (setf newNode (MoveBlankDown (car node)))
        (if newNode (incf *generated*))
        (when (and (not (null newNode)) (not (position newNode *CLOSED* :test #'equal))) (incf *DISTINCT*) (push (makeList node newNode) *OPEN*))
        (setf newNode (MoveBlankUp (car node)))
        (if newNode (incf *generated*))
        (when (and (not (null newNode)) (not (position newNode *CLOSED* :test #'equal))) (incf *DISTINCT*) (push (makeList node newNode) *OPEN*))
        (setf newNode (MoveBlankRight (car node)))
        (if newNode (incf *generated*))
        (when (and (not (null newNode)) (not (position newNode *CLOSED* :test #'equal))) (incf *DISTINCT*) (push (makeList node newNode) *OPEN*))
    )
)

(defun makeList (lst newNode)
    (let ((returnList nil))
        (dolist (item lst returnList) (if item (push item returnList)))
        (setf returnList (reverse returnList))
        (push newNode returnList)
    )
)
