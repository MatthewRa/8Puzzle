(load 'PuzzleFuncs)
(defvar *OPEN* nil)
(defvar *CLOSED* nil)
(defvar *SOLUTION* nil)
(defvar *EXPANDED* 0)
(defvar *GENERATED* 0)
(defvar *DISTINCT* 0)

(defun DFS-R (currentNode depth)
    (let ((newNode nil) (steps nil) (found nil))
        (cond
            ((IsSolved currentNode) (push currentNode steps))
            ((> depth 0)
                (incf *EXPANDED*)
                (setf newNode (MoveBlankDown currentNode))
                (cond ((shouldExpand newNode found)
                    (incf *DISTINCT*)
                    (setf found (DFS newNode (- depth 1)))
                    (if (not (null found)) (push currentNode found))
                ))
                (setf newNode (MoveBlankLeft currentNode))
                (cond ((shouldExpand newNode found)
                    (incf *DISTINCT*)
                    (setf found (DFS newNode (- depth 1)))
                    (if (not (null found)) (push currentNode found))
                ))
                (setf newNode (MoveBlankRight currentNode))
                (cond ((shouldExpand newNode found)
                    (incf *DISTINCT*)
                    (setf found (DFS newNode (- depth 1)))
                    (if (not (null found)) (push currentNode found))
                ))
                (setf newNode (MoveBlankUp currentNode))
                (cond ((shouldExpand newNode found)
                    (incf *DISTINCT*)
                    (setf found (DFS newNode (- depth 1)))
                    (if (not (null found)) (push currentNode found))
                ))
                (setf *GENERATED* (+ *GENERATED* 4))
                found
            )
            (T nil)
        )
    )
)

(defun DFS-I (root depth)
    (let ((found nil) (current nil))
        (push root *OPEN*)

        (do ((x depth (1- x))) ((or (not (null found)) (<= x 0)) found)
            (setf current (pop *OPEN*))
            (if (IsSolved current) (setf found T))
            (push current *CLOSED*)
            (GenerateSuccessors current)
            (incf *EXPANDED*)
            (setf *GENERATED* (+ *GENERATED* 4))
        )
    )
)

(defun GenerateSuccessors (node)
    (let ((newNode nil))
        (setf newNode (MoveBlankUp node))
        (if (and (not (null newNode)) (position newNode *CLOSED* :test #'equal)) (push newNode *OPEN*))
        (setf newNode (MoveBlankDown node))
        (if (and (not (null newNode)) (position newNode *CLOSED* :test #'equal)) (push newNode *OPEN*))
        (setf newNode (MoveBlankLeft node))
        (if (and (not (null newNode)) (position newNode *CLOSED* :test #'equal)) (push newNode *OPEN*))
        (setf newNode (MoveBlankRight node))
        (if (and (not (null newNode)) (position newNode *CLOSED* :test #'equal)) (push newNode *OPEN*))
    )
)

(defun shouldExpand (node found)
    (and
        (not (null node))
        (null found)
    )
)

(defun DFID-R (lst)
    (let ((solution NIL))
        (do ((x 1 (1+ x))) ((not (null solution)) solution)
            (setf solution (cdr (DFS lst x)))
        )
    )
)

(defun DFID-I (lst)
    (let ((solution NIL))
        (do ((x 1 (1+ x))) ((not (null solution)) solution)
            (setf solution (DFS-I lst x))
        )
    )
)
